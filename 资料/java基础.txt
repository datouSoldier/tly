1.web.xml 的加载顺序是：context- param -> listener -> filter -> servlet
2.同一个包下的类是不需要import的
3.implements会把interface中的属性也传过来(有点类似于extends)
4.要跨线程维护正确的可见性，只要在几个线程之间共享非 final 变量，就必须使用synchronized（或 volatile）以确保一个线程可以看见另一个线程做的更改
5.抽象类其实是可以实例化的，但是他的实例化方式不是通过new方式来创建对象,
而是通过父类的引用来指向子类的实例来间接地实现父类的实例化（因为子类要实例化前，一定会先实例化他的父类。这样创建了继承抽象类的子类的对象，
也就把其父类（抽象类）给实例化了）.但是：接口是不能被实例化的（接口压根就没有构造函数）。
6.Java类中的private方法默认是加了final关键字的不能在子类中重写如果需要重写一般写成protected.
7.try catch语句块出现异常如果捕获到了异常就会执行catch里面的语句,catch里面的执行过后会接着往下面执行(如果此时有for循环  会跳出for循环)
8.强制类型转换问题:父类型的引用指向子类型对象 Animal a=new Dog() 等同于 Dog g=new Dog();Animal b=(Dog)g这两句
  子类转父类问题 Dog gg=(Dog)new Animal则会报异常
  分析:1.只有我们的父类对象本身就是用子类new出来的时候, 才可以在将来被强制转换为子类对象.
       2.子类继承父类的所有(包括属性以及方法), 也就是说子类包含的内容应该是比父类要大的. 如果正常环境下, 把一个父类转         换成子类一定会损失精度.  但是如果父类对象本身就是用子类去new出来的, 就类似于一个本来就是儿子角色的人, 去装了一       会儿父亲, 这个角色是可以在未来转换回去的, 但是一个父亲, 永远不可能去装儿子的.              